# Augment Guidelines for Digigoods Project

## Code Styles

- Use Lombok to reduce boilerplate codes, especially when defining DTO classes.
- Refer to [`.editorconfig`](./.editorconfig) for general code styles such as indentation, line length, end-of-line symbols.
- Run `mvn checkstyle:check` to check for violations of Java code style. If violations found, read the report and try to fix them.
- Use meaningful variable names and follow camelCase convention for Java.
- Keep methods focused and single-purpose.
- Use proper access modifiers (private, protected, public) appropriately.

## Testing Guidelines

- New code should have corresponding unit tests with minimum 80% line coverage.
- Integration test of the API should be implemented using Spring's `MockMvc` that can run locally.
- Functional test of the API should be implemented using Postman collection that executed using `newman`.
- Make sure the tests still pass before and after making modification to the codebase.
- Use JUnit 5 test framework. To run the unit test suite, run `mvn test`. Make sure to run unit test suite before committing any code.
- Follow the convention of Arrange-Act-Assert (AAA) for writing tests, including providing short one-liner comments that denote the sections.

### JUnit 5 Specific Guidelines

Since we are using JUnit 5 as the test framework, please note the following when generating tests:

- Name the test methods more verbosely using Given-When-Then format: `givenValidInput_whenMethodCalled_thenExpectedResult()`
- Add `@DisplayName` annotation to all test methods and use descriptive names as the values of the annotation.
- Use `@Test` annotation for test methods.
- Use `@BeforeEach` for setup methods that run before each test.
- Use `@AfterEach` for cleanup methods that run after each test.
- Use appropriate assertions from `org.junit.jupiter.api.Assertions` class.
- Use `@MockitoExtension` when mocking dependencies.
- Use `@InjectMocks` and `@Mock` annotations properly for dependency injection in tests.

### Test Structure and Patterns

- **Arrange Section**: Set up test data, mock behaviors, and prepare the system under test
- **Act Section**: Execute the method or functionality being tested
- **Assert Section**: Verify the expected outcomes and behaviors

Example test structure:
```java
@Test
@DisplayName("Should return user profile when valid ID is provided")
void givenValidUserId_whenGetUserProfile_thenReturnUserProfile() {
    // Arrange - Set up test data and mocks
    Long userId = 1L;
    UserProfile expectedProfile = new UserProfile();
    
    // Act - Execute the method under test
    UserProfile actualProfile = userService.getUserProfile(userId);
    
    // Assert - Verify the results
    assertThat(actualProfile).isEqualTo(expectedProfile);
}
```

### Error Handling Tests

- Always include tests for exception scenarios
- Use `assertThrows()` to verify expected exceptions
- Test both the exception type and message when applicable
- Include tests for validation failures and edge cases

### Mock Usage Guidelines

- Mock external dependencies and collaborating services
- Use `@MockitoExtension` for Mockito integration
- Verify important interactions with mocks using `verify()`
- Use argument matchers when appropriate (`any()`, `eq()`, etc.)
- Avoid over-mocking - only mock what's necessary for the test

## Code Coverage

- When asked to increase coverage for a specific source code file, check the coverage report first.
- The coverage report of a source code file can be found in `target/site/jacoco/[package name]/[class name].html`.
- When reading the coverage report, identify which lines and branches are not yet covered.
- Make sure to run `mvn test` before and after adding tests.
- Aim for at least 80% line coverage and 70% branch coverage.
- Focus on testing critical business logic and error handling paths.

## DTO and Entity Guidelines

- Use Lombok annotations to reduce boilerplate code:
  - `@Data` for getters, setters, toString, equals, and hashCode
  - `@Builder` for builder pattern
  - `@NoArgsConstructor` and `@AllArgsConstructor` for constructors
  - `@Entity` for JPA entities
  - `@Table` for custom table names
- Separate DTOs from entities to maintain clean architecture
- Use validation annotations (`@NotNull`, `@NotBlank`, `@Valid`, etc.) on DTOs
- Follow naming conventions: entities end with nothing, DTOs end with "Dto"

## Service Layer Guidelines

- Use `@Service` annotation for service classes
- Implement business logic in service layer, not in controllers
- Use `@Transactional` for methods that modify data
- Handle exceptions appropriately and throw meaningful custom exceptions
- Use dependency injection with constructor injection (recommended) or `@Autowired`
- Keep services focused on single responsibility

## Controller Layer Guidelines

- Use `@RestController` for REST API controllers
- Use appropriate HTTP methods and status codes
- Use `@RequestMapping`, `@GetMapping`, `@PostMapping`, etc. appropriately
- Validate input using `@Valid` and validation annotations
- Return appropriate response types (`ResponseEntity`, DTOs)
- Handle exceptions using `@ExceptionHandler` or global exception handlers
- Use proper path variables and request parameters

## Documentation Standards

- Use JavaDoc comments for public methods and classes
- Include parameter descriptions, return value descriptions, and exception information
- Keep comments concise but informative
- Update comments when code changes
- Use meaningful commit messages following conventional commits format

## Security Considerations

- Always validate input data
- Use proper authentication and authorization
- Don't expose sensitive information in error messages
- Use HTTPS for all communications
- Implement proper session management
- Follow OWASP security guidelines
